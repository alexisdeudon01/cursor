<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Explorer Architecture Client / Serveur</title>

    <!-- Mermaid -->
    <script type="module">
        import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
        mermaid.initialize({
            startOnLoad: false,
            theme: "default",
            securityLevel: "loose"
        });
        window.mermaid = mermaid;
    </script>

    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            display: flex;
            height: 100vh;
            color: #111827;
            background: #f3f4f6;
        }

        #sidebar {
            width: 300px;
            background: #111827;
            color: #e5e7eb;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            overflow: auto;
        }

        #sidebar h1 {
            margin: 0;
            font-size: 1.2rem;
            color: #f9fafb;
        }

        #sidebar p {
            margin: 4px 0 0 0;
            font-size: 0.8rem;
            color: #9ca3af;
        }

        #main {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: 100vh;
            min-width: 0;
        }

        #toolbar {
            padding: 8px 12px;
            background: #ffffff;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            align-items: center;
            gap: 10px;
            min-height: 48px;
        }

        #toolbar-info {
            flex: 1;
        }

        #content {
            flex: 1;
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 0;
            height: calc(100vh - 48px);
            min-height: 0;
        }

        #diagram-panel {
            border-right: 1px solid #e5e7eb;
            padding: 12px 16px;
            overflow: hidden;
            background: #f9fafb;

            display: flex;
            flex-direction: column;
            min-width: 0;
            min-height: 0;
        }

        #analysis-panel {
            padding: 12px 16px;
            overflow: auto;
            background: #ffffff;
            min-width: 0;
            min-height: 0;
        }

        .section-title {
            margin: 0 0 8px 0;
            font-size: 1rem;
        }

        .nav-section-title {
            margin: 12px 0 4px 0;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            color: #9ca3af;
        }

        button {
            font-family: inherit;
        }

        .btn {
            border: none;
            border-radius: 8px;
            padding: 8px 10px;
            font-size: 0.85rem;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            user-select: none;
        }

        .btn-primary {
            background: #2563eb;
            color: #f9fafb;
        }

        .btn-primary:hover {
            background: #1d4ed8;
        }

        .btn-ghost {
            background: transparent;
            color: #e5e7eb;
        }

        .btn-ghost:hover {
            background: #1f2937;
        }

        .nav-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .nav-item {
            border-radius: 8px;
            padding: 8px 10px;
            font-size: 0.85rem;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.03);
        }

        .nav-item:hover {
            background: #1f2937;
        }

        .nav-item.active {
            background: #2563eb;
            color: #f9fafb;
        }

        #current-view-title {
            font-size: 0.95rem;
            font-weight: 650;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .pill {
            font-size: 0.75rem;
            padding: 4px 8px;
            border-radius: 999px;
            background: #e5e7eb;
            color: #111827;
        }

        .small-hint {
            font-size: 0.82rem;
            color: #6b7280;
        }

        /* DIAGRAM FULL SPACE */
        #diagram-container {
            flex: 1;
            width: 100%;
            border-radius: 10px;
            background: #ffffff;
            padding: 0;
            overflow: auto;
            min-height: 0;
            min-width: 0;
        }

        .mmd-wrapper {
            width: 100%;
            margin: 14px 0;
            padding: 10px;
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.06);
            overflow: auto;
        }

        #diagram-container svg {
            /* Laisse le SVG √† sa largeur naturelle pour √©viter l'√©crasement des super-diagrammes */
            width: auto !important;
            max-width: none !important;
            height: auto !important;
            display: block;
        }

        #analysis-container {
            border-radius: 10px;
            background: #f9fafb;
            padding: 10px;
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .card {
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            padding: 10px;
        }

        .mono {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
            font-size: 0.82rem;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .kpi {
            font-size: 1.2rem;
            font-weight: 750;
        }

        .muted {
            color: #6b7280;
        }

        .warn {
            color: #b45309;
        }

        .bad {
            color: #b91c1c;
        }

        .ok {
            color: #047857;
        }

        .list-tight {
            margin: 6px 0 0 18px;
            padding: 0;
        }

        .list-tight li {
            margin: 4px 0;
        }

        .btn-mini {
            border: 1px solid #e5e7eb;
            background: #fff;
            border-radius: 8px;
            padding: 6px 8px;
            font-size: 0.82rem;
            cursor: pointer;
        }

        .btn-mini:hover {
            background: #f3f4f6;
        }
    </style>
</head>

<body>
    <aside id="sidebar">
        <div>
            <h1>Explorer Architecture</h1>
            <p>Client / Serveur / Shared ‚Ä¢ Sessions ‚Ä¢ Jeux</p>
        </div>

        <div>
            <div class="nav-section-title">Chargement</div>
            <button class="btn btn-ghost" id="choose-folder-btn">üìÅ Choisir un dossier de .md</button>
            <p class="small-hint">
                Le dossier doit contenir des fichiers <code>.md</code> avec des blocs <code>```mermaid</code>.
            </p>
            <div id="folder-status" class="small-hint"></div>
        </div>

        <div>
            <div class="nav-section-title">Vues disponibles</div>
            <div id="views-list" class="nav-list"></div>
        </div>

        <div>
            <div class="nav-section-title">Navigation classes</div>
            <div id="class-shortcuts" class="nav-list"></div>
        </div>
    </aside>

    <main id="main">
        <div id="toolbar">
            <div id="toolbar-info" class="small-hint">
                Aucun dossier charg√©. Choisis un dossier de fichiers <code>.md</code>.
            </div>
            <button class="btn btn-primary" id="btn-focus">üß† Focus diagramme</button>
        </div>

        <div id="content">
            <section id="diagram-panel">
                <h2 class="section-title">Diagramme / Vue</h2>
                <div id="current-view-title">Aucune vue s√©lectionn√©e</div>
                <div id="diagram-container">
                    <p class="small-hint" style="padding: 12px;">
                        Une fois le dossier charg√©, s√©lectionne une vue.
                    </p>
                </div>
            </section>

            <aside id="analysis-panel">
                <h2 class="section-title">Analyse & d√©tails</h2>
                <div id="analysis-container">
                    <p class="small-hint">
                        Ici tu verras : stats, patterns, liaisons, incoh√©rences, et les d√©tails d‚Äôune classe.
                    </p>
                </div>
            </aside>
        </div>
    </main>

    <script>
        // -------------------------------------------------------------
        // √âTAT
        // -------------------------------------------------------------
        const appState = {
            directoryHandle: null,
            files: [], // { name, content }
            classIndex: {}, // voir buildGraphIndex()
            graph: null,    // stats + adjacency
            focusMode: false
        };

        const chooseFolderBtn = document.getElementById("choose-folder-btn");
        const folderStatusEl = document.getElementById("folder-status");
        const toolbarInfoEl = document.getElementById("toolbar-info");
        const viewsListEl = document.getElementById("views-list");
        const diagramContainerEl = document.getElementById("diagram-container");
        const currentViewTitleEl = document.getElementById("current-view-title");
        const analysisContainerEl = document.getElementById("analysis-container");
        const classShortcutsEl = document.getElementById("class-shortcuts");
        const btnFocus = document.getElementById("btn-focus");
        const analysisPanel = document.getElementById("analysis-panel");
        const contentEl = document.getElementById("content");

        // -------------------------------------------------------------
        // UTIL
        // -------------------------------------------------------------
        function isFileSystemAPISupported() {
            return "showDirectoryPicker" in window;
        }

        function escapeHtml(str) {
            return str
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;");
        }

        // -------------------------------------------------------------
        // MERMAID: extraction + fix + rendu
        // -------------------------------------------------------------
        function extractMermaidBlocks(mdText) {
            const blocks = [];
            const regex = /```mermaid([\s\S]*?)```/g;
            let match;
            while ((match = regex.exec(mdText)) !== null) blocks.push(match[1].trim());
            return blocks;
        }

	        function fixMermaidCode(code) {
	            let fixed = code;

            // 1) d√©gager PlantUML
            fixed = fixed.replace(/^\s*!include.*$/gmi, "");
            fixed = fixed.replace(/^\s*puml\s*$/gmi, "");
            fixed = fixed.replace(/@startuml|@enduml/gmi, "");

	            // 2) points dans noms => underscore
	            fixed = fixed.replace(/([A-Za-z0-9]+)\.([A-Za-z0-9]+)/g, "$1_$2");

	            // 2b) supprime les commentaires "%%" en fin de ligne (souvent invalides dans erDiagram)
	            // Ex: "string State %% Lobby | Starting" => "string State"
	            fixed = fixed.replace(/(\S)\s*%%.*$/gm, "$1");

            // 3) notes PlantUML -> notes Mermaid
            fixed = fixed.replace(/note\s+"([^"]+)"\s*$/gmi, "note right\n$1\nend note");
            fixed = fixed.replace(/note\s+for\s+([A-Za-z0-9_]+)\s+"([^"]+)"/gmi, "note right of $1\n$2\nend note");

            // 4) labels flowchart avec ":" chiant

            // fixed = fixed.replace(/--\s*"([^"]+):([^"]+)"\s*-->/g, function (_, a, b) {
            //   return '-- "' + a + ' - ' + b + '" -->';
            //});/*/
            fixed = fixed.replace(/--\s*'([^']+):([^']+)'\s*-->/g, function (_, a, b) {
                return "-- '" + a + ' - ' + b + "' -->";
            });
            // 5) bloc C4-PlantUML : on ignore proprement
            if (/C4Component|Container_Boundary|Component|Rel\(/.test(fixed)) {
                return "// Diagramme C4 non support√© par Mermaid";
            }

            return fixed.trim();
        }

        async function renderMermaidDiagram(code, container) {
            try {
                if (!window.mermaid || typeof window.mermaid.render !== "function") {
                    console.warn("Mermaid pas pr√™t");
                    return;
                }

                const cleaned = fixMermaidCode(code);
                if (!cleaned || cleaned.startsWith("//")) {
                    console.warn(cleaned || "Diagramme vide");
                    return;
                }

                const id = "mmd_" + Math.random().toString(36).substring(2, 10);
                const { svg } = await window.mermaid.render(id, cleaned);

                const wrapper = document.createElement("div");
                wrapper.className = "mmd-wrapper";
                wrapper.innerHTML = svg;
                container.appendChild(wrapper);

                // Click sur classe (quand possible)
                attachSvgNodeClickHandlers(wrapper);

            } catch (err) {
                // IMPORTANT: pas d'erreur affich√©e dans l'UI, juste console
                console.error("Erreur Mermaid :", err);
            }
        }

        function attachSvgNodeClickHandlers(wrapper) {
            const svg = wrapper.querySelector("svg");
            if (!svg) return;

            // Mermaid classDiagram: les nodes sont souvent des <g class="node"> avec texte
            const nodes = svg.querySelectorAll("g[class*='node']");
            nodes.forEach(node => {
                node.style.cursor = "pointer";
                node.addEventListener("click", () => {
                    const label = (node.textContent || "").trim();
                    const key = findClassKeyFromLabel(label);
                    if (!key) return;
                    showClassDetails(key);
                    highlightClassInDiagrams(key);
                });
            });
        }

        function findClassKeyFromLabel(label) {
            if (!label) return null;
            if (appState.classIndex[label]) return label;

            const normalized = normalizeClassName(label);
            if (appState.classIndex[normalized]) return normalized;

            // Suffix match (_Label) si unique (utile quand Mermaid affiche sans namespace)
            const suffix = `_${label}`;
            const matches = Object.keys(appState.classIndex).filter(k => k.endsWith(suffix));
            if (matches.length === 1) return matches[0];

            // Alias map (si on a d√©j√† vu une version pr√©fix√©e)
            if (nameAlias.has(label)) {
                const aliased = nameAlias.get(label);
                if (appState.classIndex[aliased]) return aliased;
            }

            return null;
        }

        // -------------------------------------------------------------
        // PARSE CLASSES / RELATIONS (classDiagram)
        // -------------------------------------------------------------
        function extractClassesFromClassDiagram(code) {
            const classes = [];
            const lines = code.split(/\r?\n/);
            const nsStack = [];
            const blockStack = []; // "namespace" | "class"

            for (const rawLine of lines) {
                const line = rawLine.trim();
                const openNs = line.match(/^namespace\s+([A-Za-z0-9_]+)\s*\{/);
                if (openNs) {
                    nsStack.push(openNs[1]);
                    blockStack.push("namespace");
                    continue;
                }

                // Gestion des blocs: les classes ont aussi des { } (ne pas confondre avec namespace)
                if (line === "}") {
                    const last = blockStack.pop();
                    if (last === "namespace") nsStack.pop();
                    continue;
                }

                const cls = line.match(/class\s+([A-Za-z0-9_]+)/);
                if (cls) {
                    classes.push({
                        name: cls[1],
                        namespace: nsStack[nsStack.length - 1] || null
                    });

                    if (line.includes("{")) {
                        blockStack.push("class");
                    }
                }
            }
            return classes;
        }

        function extractRelationsFromClassDiagram(code) {
            const relations = [];
            const lines = code.split(/\r?\n/);

            // couvre:
            // - A --> B
            // - A "1" *-- "0..*" B : label
            // - A --|> B
            const regex = /^\s*([A-Za-z0-9_]+)\s*(?:"[^"]+"\s*)?[-.*o<|]+[->|.]+\s*(?:"[^"]+"\s*)?([A-Za-z0-9_]+)\b/;

            for (const rawLine of lines) {
                const line = rawLine.trim();
                if (!line) continue;
                if (line.startsWith("classDiagram")) continue;
                if (line.startsWith("class ")) continue;
                if (line.startsWith("namespace ")) continue;
                if (line === "}") continue;

                const m = line.match(regex);
                if (m) relations.push({ from: m[1], to: m[2] });
            }
            return relations;
        }

        function detectClassType(className) {
            if (/Manager$/i.test(className)) return "Manager";
            if (/Handler$/i.test(className)) return "Handler";
            if (/Container$/i.test(className)) return "Container";
            if (/Bootstrap$/i.test(className)) return "Bootstrap";
            if (/UI$/i.test(className) || /UIController$/i.test(className)) return "UI";
            if (/Registry$/i.test(className)) return "Registry";
            if (/Hub$/i.test(className)) return "Hub";
            if (/Definition$/i.test(className)) return "Definition";
            return "Other";
        }

        const nameAlias = new Map();

        function normalizeClassName(rawName, nsHint = null) {
            if (!rawName) return "";
            let n = rawName.trim();
            n = n.replace(/\s+/g, "");
            n = n.replace(/\.|::/g, "_");
            n = n.replace(/_{2,}/g, "_");
            n = n.replace(/^(Server|Client|StateSync)_\1_/i, "$1_");

            if (nsHint) {
                // Certains types existent des deux c√¥t√©s (Netcode) => on les traite comme "Shared"
                if (/^SessionRpcHub$/i.test(n)) {
                    const preferred = `Shared_${n}`;
                    nameAlias.set(n, preferred);
                    nameAlias.set(`${nsHint}_${n}`, preferred);
                    return preferred;
                }

                const preferred = `${nsHint}_${n}`;
                nameAlias.set(n, preferred);
                return preferred;
            }

            const prefMatch = n.match(/^(Server|Client|StateSync)_(.+)$/i);
            if (prefMatch) {
                const base = prefMatch[2];
                if (!nameAlias.has(base)) nameAlias.set(base, n);
                return n;
            }

            if (nameAlias.has(n)) return nameAlias.get(n);

            for (const [base, alias] of nameAlias.entries()) {
                if (base === n) return alias;
            }

            return n;
        }

        function resolveNamespace(name, nsHint = null) {
            if (nsHint) {
                if (String(nsHint).toLowerCase() === "statesync") return "Shared";
                if (/_SessionRpcHub$/i.test(name)) return "Shared";
                return nsHint;
            }

            // StateSync fait partie de Shared (√©vite les faux positifs sur "Client" dans GameCommandClient, etc.)
            if (/^StateSync_/i.test(name)) return "Shared";

            // SessionRpcHub est "shared" (existe c√¥t√© client et serveur via Netcode)
            if (/_SessionRpcHub$/i.test(name)) return "Shared";

            const m = name.match(/^(Server|Client)_/i);
            if (m) return m[1];
            if (/Server/i.test(name)) return "Server";
            if (/Client/i.test(name)) return "Client";
            return "Shared";
        }

        function detectNamespace(className) {
            return resolveNamespace(className);
        }

        // -------------------------------------------------------------
        // BUILD INDEX + GRAPH STATS
        // -------------------------------------------------------------
        function buildGraphIndex() {
            appState.classIndex = {};
            nameAlias.clear();

            // Collecte brute
            for (const file of appState.files) {
                const blocks = extractMermaidBlocks(file.content);

                for (const rawBlock of blocks) {
                    const block = fixMermaidCode(rawBlock);

                    if (!block.includes("classDiagram")) continue;
                    if (block.startsWith("//")) continue;

                    const classes = extractClassesFromClassDiagram(block);
                    const relations = extractRelationsFromClassDiagram(block);

                    // Classes
                    for (const cls of classes) {
                        const canonical = normalizeClassName(cls.name, cls.namespace);
                        const ns = resolveNamespace(canonical, cls.namespace);
                        if (!appState.classIndex[canonical]) {
                            appState.classIndex[canonical] = {
                                name: canonical,
                                files: new Set(),
                                type: detectClassType(canonical),
                                namespace: ns,
                                outgoing: new Set(),
                                incoming: new Set(),
                                // pour expliquer d'o√π vient la relation
                                relFilesOut: new Map(), // to -> Set(files)
                                relFilesIn: new Map()   // from -> Set(files)
                            };
                        } else {
                            // Si on rencontre une d√©finition plus pr√©cise (nsHint), on met √† jour le namespace si besoin.
                            if (ns && appState.classIndex[canonical].namespace !== ns) {
                                appState.classIndex[canonical].namespace = ns;
                            }
                        }
                        appState.classIndex[canonical].files.add(file.name);
                    }

                    // Relations
                    for (const rel of relations) {
                        const from = normalizeClassName(rel.from);
                        const to = normalizeClassName(rel.to);

                        // On cr√©e aussi les classes si elles existent que via relations
                        for (const n of [from, to]) {
                            if (!appState.classIndex[n]) {
                                appState.classIndex[n] = {
                                    name: n,
                                    files: new Set([file.name]),
                                    type: detectClassType(n),
                                    namespace: resolveNamespace(n),
                                    outgoing: new Set(),
                                    incoming: new Set(),
                                    relFilesOut: new Map(),
                                    relFilesIn: new Map()
                                };
                            } else {
                                appState.classIndex[n].files.add(file.name);
                            }
                        }

                        appState.classIndex[from].outgoing.add(to);
                        appState.classIndex[to].incoming.add(from);

                        if (!appState.classIndex[from].relFilesOut.has(to)) {
                            appState.classIndex[from].relFilesOut.set(to, new Set());
                        }
                        appState.classIndex[from].relFilesOut.get(to).add(file.name);

                        if (!appState.classIndex[to].relFilesIn.has(from)) {
                            appState.classIndex[to].relFilesIn.set(from, new Set());
                        }
                        appState.classIndex[to].relFilesIn.get(from).add(file.name);
                    }
                }
            }

            // freeze sets -> arrays friendly
            for (const cls of Object.values(appState.classIndex)) {
                cls.files = Array.from(cls.files).sort();
                cls.outgoing = Array.from(cls.outgoing).sort();
                cls.incoming = Array.from(cls.incoming).sort();
            }

            appState.graph = computeGraphStats();
        }

        function computeGraphStats() {
            const nodes = Object.keys(appState.classIndex);
            const n = nodes.length;

            let edgeCount = 0;
            const edges = [];
            for (const cls of Object.values(appState.classIndex)) {
                for (const to of cls.outgoing) {
                    edgeCount++;
                    edges.push([cls.name, to]);
                }
            }

            // Degrees
            const degree = nodes.map(name => {
                const c = appState.classIndex[name];
                return {
                    name,
                    out: c.outgoing.length,
                    in: c.incoming.length,
                    total: c.outgoing.length + c.incoming.length,
                    type: c.type,
                    ns: c.namespace
                };
            });

            const topOut = [...degree].sort((a, b) => b.out - a.out).slice(0, 10);
            const topIn = [...degree].sort((a, b) => b.in - a.in).slice(0, 10);
            const topHub = [...degree].sort((a, b) => b.total - a.total).slice(0, 10);

            // Orphans / isolated
            const isolated = degree.filter(d => d.total === 0).map(d => d.name);

            // Cross-namespace edges
            let crossNs = 0;
            const crossNsEdges = [];
            for (const [a, b] of edges) {
                const na = appState.classIndex[a]?.namespace;
                const nb = appState.classIndex[b]?.namespace;
                // On ne compte ici que Client <-> Server (Shared est neutre)
                if (na && nb && na !== nb && (na === "Client" || na === "Server") && (nb === "Client" || nb === "Server")) {
                    crossNs++;
                    crossNsEdges.push({ from: a, to: b, fromNs: na, toNs: nb });
                }
            }

            // Simple layering rules (optionnel mais utile)
            // - Client -> Server direct = suspect
            // - Server -> Client direct = suspect
            const layeringIssues = [];
            for (const e of crossNsEdges) {
                if (e.fromNs === "Client" && e.toNs === "Server") {
                    layeringIssues.push(`‚ö†Ô∏è D√©pendance directe Client ‚Üí Server : ${e.from} ‚Üí ${e.to}`);
                }
                if (e.fromNs === "Server" && e.toNs === "Client") {
                    layeringIssues.push(`‚ö†Ô∏è D√©pendance directe Server ‚Üí Client : ${e.from} ‚Üí ${e.to}`);
                }
            }

            // Cycles (DFS)
            const cycles = findCyclesLimited(12); // on limite pour pas exploser

            // Type patterns checks
            const patternIssues = [];

            // Handlers sans Manager en sortie
            for (const c of Object.values(appState.classIndex)) {
                if (c.type === "Handler") {
                    const hasManager = c.outgoing.some(t => appState.classIndex[t]?.type === "Manager");
                    const hasContainer = c.outgoing.some(t => appState.classIndex[t]?.type === "Container");
                    const hasHub = c.outgoing.some(t => appState.classIndex[t]?.type === "Hub");
                    if (!hasManager && !hasContainer && !hasHub) {
                        patternIssues.push(`‚ö†Ô∏è Handler sans lien vers Manager/Container/Hub : ${c.name}`);
                    }
                }
            }

            // Managers sans Container en sortie
            for (const c of Object.values(appState.classIndex)) {
                if (c.type === "Manager") {
                    const hasContainer = c.outgoing.some(t => appState.classIndex[t]?.type === "Container");
                    if (!hasContainer) patternIssues.push(`‚ö†Ô∏è Manager sans lien vers Container : ${c.name}`);
                }
            }

            // Couplage (arbitraire, ajustable)
            const couplingIssues = [];
            for (const d of degree) {
                if (d.out >= 10) couplingIssues.push(`‚ö†Ô∏è ${d.name} a ${d.out} sorties (fort couplage)`);
                if (d.in >= 10) couplingIssues.push(`‚ö†Ô∏è ${d.name} a ${d.in} entr√©es (gros hub / point chaud)`);
            }

            // R√©partition par type / namespace
            const byType = {};
            const byNs = {};
            degree.forEach(d => {
                byType[d.type] = (byType[d.type] || 0) + 1;
                byNs[d.ns] = (byNs[d.ns] || 0) + 1;
            });

            const density = n > 1 ? (edgeCount / (n * (n - 1))) : 0;

            return {
                n, edgeCount, density,
                byType, byNs,
                topOut, topIn, topHub,
                isolated,
                crossNs, crossNsEdges: crossNsEdges.slice(0, 30),
                layeringIssues: layeringIssues.slice(0, 25),
                cycles: cycles.slice(0, 20),
                patternIssues: patternIssues.slice(0, 25),
                couplingIssues: couplingIssues.slice(0, 25),
            };
        }

        function findCyclesLimited(limit = 10) {
            const idx = appState.classIndex;
            const visited = new Set();
            const inStack = new Set();
            const stack = [];
            const cycles = [];

            function dfs(node) {
                if (cycles.length >= limit) return;
                visited.add(node);
                inStack.add(node);
                stack.push(node);

                const outs = idx[node]?.outgoing || [];
                for (const next of outs) {
                    if (cycles.length >= limit) break;

                    if (!visited.has(next)) {
                        dfs(next);
                    } else if (inStack.has(next)) {
                        // cycle found: extract path
                        const i = stack.indexOf(next);
                        if (i !== -1) {
                            const cyc = stack.slice(i).concat([next]);
                            cycles.push("üîÅ " + cyc.join(" ‚Üí "));
                        }
                    }
                }

                stack.pop();
                inStack.delete(node);
            }

            for (const node of Object.keys(idx)) {
                if (cycles.length >= limit) break;
                if (!visited.has(node)) dfs(node);
            }
            return cycles;
        }

        // -------------------------------------------------------------
        // UI: VUES
        // -------------------------------------------------------------
        function initializeViewsFromFiles() {
            viewsListEl.innerHTML = "";

            const addItem = (label, key) => {
                const item = document.createElement("div");
                item.className = "nav-item";
                item.textContent = label;
                item.dataset.viewKey = key;
                item.addEventListener("click", () => selectView(key));
                viewsListEl.appendChild(item);
            };

            addItem("Fusion documentaire (tous les fichiers)", "fusion-doc");
            addItem("Super-diagramme (par namespace)", "super-ns");
            addItem("Super-diagramme (par type)", "super-type");
            addItem("Vue combin√©e (Architecture compl√®te)", "combined");

            // une vue par fichier
            for (const file of appState.files) {
                addItem(file.name, `file:${file.name}`);
            }

            diagramContainerEl.innerHTML = "<p class='small-hint' style='padding:12px;'>S√©lectionne une vue.</p>";
            currentViewTitleEl.textContent = "Aucune vue s√©lectionn√©e";
            generateClassShortcuts();
            showAnalysisSummary();
        }

        // -------------------------------------------------------------
        // UI: Sidebar shortcuts
        // -------------------------------------------------------------
        function generateClassShortcuts() {
            classShortcutsEl.innerHTML = "";

            const groups = {
                Manager: [], Handler: [], Container: [], Bootstrap: [],
                UI: [], Registry: [], Hub: [], Definition: [], Other: []
            };

            for (const cls of Object.values(appState.classIndex)) groups[cls.type].push(cls);

            for (const [type, list] of Object.entries(groups)) {
                if (!list.length) continue;

                const title = document.createElement("div");
                title.className = "nav-section-title";
                title.textContent = type;
                classShortcutsEl.appendChild(title);

                list
                    .sort((a, b) => a.name.localeCompare(b.name))
                    .slice(0, 80) // √©vite sidebar infinie si √©norme
                    .forEach(cls => {
                        const item = document.createElement("div");
                        item.className = "nav-item";
                        item.textContent = cls.name;
                        item.addEventListener("click", () => {
                            showClassDetails(cls.name);
                            highlightClassInDiagrams(cls.name);
                        });
                        classShortcutsEl.appendChild(item);
                    });

                if (list.length > 80) {
                    const more = document.createElement("div");
                    more.className = "small-hint";
                    more.textContent = `+ ${list.length - 80} autres‚Ä¶ (utilise click dans les diagrammes)`;
                    classShortcutsEl.appendChild(more);
                }
            }
        }

        // -------------------------------------------------------------
        // UI: Analyse (global + class)
        // -------------------------------------------------------------
        function showAnalysisSummary() {
            const g = appState.graph;
            if (!g) {
                analysisContainerEl.innerHTML = `<p class="small-hint">Charge un dossier pour lancer l‚Äôanalyse.</p>`;
                return;
            }

            const byType = Object.entries(g.byType)
                .sort((a, b) => b[1] - a[1])
                .map(([k, v]) => `<li><strong>${k}</strong> : ${v}</li>`).join("");

            const byNs = Object.entries(g.byNs)
                .sort((a, b) => b[1] - a[1])
                .map(([k, v]) => `<li><strong>${k}</strong> : ${v}</li>`).join("");

            const topHub = g.topHub.map(d => `<li><span class="mono">${d.name}</span> <span class="muted">(${d.total} liens)</span></li>`).join("");
            const topOut = g.topOut.map(d => `<li><span class="mono">${d.name}</span> <span class="muted">(${d.out} sorties)</span></li>`).join("");
            const topIn = g.topIn.map(d => `<li><span class="mono">${d.name}</span> <span class="muted">(${d.in} entr√©es)</span></li>`).join("");

            const isolated = g.isolated.length
                ? g.isolated.slice(0, 20).map(n => `<li><span class="mono">${n}</span></li>`).join("")
                : `<li class="ok">‚úÖ Aucune classe isol√©e d√©tect√©e</li>`;

            const cycles = g.cycles.length
                ? g.cycles.map(c => `<li class="bad">${escapeHtml(c)}</li>`).join("")
                : `<li class="ok">‚úÖ Aucun cycle d√©tect√© (ou pas captur√©)</li>`;

            const layering = g.layeringIssues.length
                ? g.layeringIssues.map(x => `<li class="warn">${escapeHtml(x)}</li>`).join("")
                : `<li class="ok">‚úÖ Pas d‚Äôalerte Client‚ÜîServer direct</li>`;

            const patterns = g.patternIssues.length
                ? g.patternIssues.map(x => `<li class="warn">${escapeHtml(x)}</li>`).join("")
                : `<li class="ok">‚úÖ Patterns OK (dans les r√®gles simples)</li>`;

            const coupling = g.couplingIssues.length
                ? g.couplingIssues.map(x => `<li class="warn">${escapeHtml(x)}</li>`).join("")
                : `<li class="ok">‚úÖ Couplage global ok (seuils actuels)</li>`;

            analysisContainerEl.innerHTML = `
        <div class="grid">
          <div class="card">
            <div class="kpi">${g.n}</div>
            <div class="muted">classes</div>
          </div>
          <div class="card">
            <div class="kpi">${g.edgeCount}</div>
            <div class="muted">liaisons</div>
          </div>
        </div>

        <div class="card" style="margin-top:10px;">
          <strong>R√©partition</strong>
          <div class="grid" style="margin-top:8px;">
            <div>
              <div class="muted" style="margin-bottom:4px;">Par type</div>
              <ul class="list-tight">${byType}</ul>
            </div>
            <div>
              <div class="muted" style="margin-bottom:4px;">Par namespace</div>
              <ul class="list-tight">${byNs}</ul>
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:10px;">
          <strong>Top ‚Äúhubs‚Äù</strong>
          <div class="grid" style="margin-top:8px;">
            <div>
              <div class="muted">Total liens</div>
              <ul class="list-tight">${topHub}</ul>
            </div>
            <div>
              <div class="muted">Sorties / Entr√©es</div>
              <ul class="list-tight">${topOut}</ul>
              <div class="muted" style="margin-top:8px;">---</div>
              <ul class="list-tight">${topIn}</ul>
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:10px;">
          <strong>Incoh√©rences & risques</strong>
          <div class="grid" style="margin-top:8px;">
            <div>
              <div class="muted">Cycles</div>
              <ul class="list-tight">${cycles}</ul>
            </div>
            <div>
              <div class="muted">Couplage / patterns</div>
              <ul class="list-tight">${coupling}</ul>
              <div class="muted" style="margin-top:8px;">---</div>
              <ul class="list-tight">${patterns}</ul>
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:10px;">
          <strong>R√®gles d‚Äôarchi (Client/Server)</strong>
          <ul class="list-tight" style="margin-top:8px;">${layering}</ul>
          <div class="muted" style="margin-top:8px;">Astuce: clique une classe dans un diagramme pour voir ses d√©tails.</div>
        </div>

        <div class="card" style="margin-top:10px;">
          <strong>Classes isol√©es</strong>
          <ul class="list-tight" style="margin-top:8px;">${isolated}</ul>
        </div>
      `;
        }

        function showClassDetails(className) {
            const cls = appState.classIndex[className];
            if (!cls) return;

            const out = cls.outgoing;
            const inn = cls.incoming;

            // sortants avec fichiers source
            const outLines = out.length
                ? out.map(to => {
                    const files = cls.relFilesOut?.get?.(to) ? Array.from(cls.relFilesOut.get(to)).sort() : [];
                    const filesStr = files.length ? ` <span class="muted">(${files.join(", ")})</span>` : "";
                    return `<li><span class="mono">${to}</span>${filesStr}</li>`;
                }).join("")
                : `<li class="muted">Aucune</li>`;

            // entrants avec fichiers source
            const inLines = inn.length
                ? inn.map(from => {
                    const files = cls.relFilesIn?.get?.(from) ? Array.from(cls.relFilesIn.get(from)).sort() : [];
                    const filesStr = files.length ? ` <span class="muted">(${files.join(", ")})</span>` : "";
                    return `<li><span class="mono">${from}</span>${filesStr}</li>`;
                }).join("")
                : `<li class="muted">Aucune</li>`;

            const files = cls.files?.length ? cls.files.map(f => `<li><span class="mono">${f}</span></li>`).join("") : "<li class='muted'>‚Äî</li>";

            // mini diagnostic de la classe
            const hints = [];
            if (out.length >= 10) hints.push(`‚ö†Ô∏è beaucoup de sorties (${out.length}) ‚Üí couplage`);
            if (inn.length >= 10) hints.push(`‚ö†Ô∏è beaucoup d‚Äôentr√©es (${inn.length}) ‚Üí point chaud`);
            if (out.length === 0 && inn.length === 0) hints.push(`‚ö†Ô∏è isol√©e ‚Üí peut-√™tre oubli√©e / doc incompl√®te`);
            if (cls.type === "Handler") {
                const hasManager = out.some(t => appState.classIndex[t]?.type === "Manager");
                if (!hasManager) hints.push(`‚ö†Ô∏è Handler sans Manager cible`);
            }
            if (cls.type === "Manager") {
                const hasContainer = out.some(t => appState.classIndex[t]?.type === "Container");
                if (!hasContainer) hints.push(`‚ö†Ô∏è Manager sans Container cible`);
            }

            analysisContainerEl.innerHTML = `
        <div class="card">
          <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
            <div>
              <div style="font-size:1.05rem; font-weight:800;">${escapeHtml(cls.name)}</div>
              <div class="muted">Type: <strong>${cls.type}</strong> ‚Ä¢ Namespace: <strong>${cls.namespace}</strong></div>
            </div>
            <div style="display:flex; gap:8px; flex-wrap:wrap;">
              <button class="btn-mini" id="btn-back-summary">‚¨ÖÔ∏è Retour stats</button>
              <button class="btn-mini" id="btn-highlight">‚ú® Highlight</button>
            </div>
          </div>
        </div>

        <div class="grid" style="margin-top:10px;">
          <div class="card">
            <strong>Liaisons sortantes</strong>
            <div class="muted">${out.length} sortie(s)</div>
            <ul class="list-tight" style="margin-top:8px;">${outLines}</ul>
          </div>

          <div class="card">
            <strong>Liaisons entrantes</strong>
            <div class="muted">${inn.length} entr√©e(s)</div>
            <ul class="list-tight" style="margin-top:8px;">${inLines}</ul>
          </div>
        </div>

        <div class="card" style="margin-top:10px;">
          <strong>Fichiers o√π la classe appara√Æt</strong>
          <ul class="list-tight" style="margin-top:8px;">${files}</ul>
        </div>

        <div class="card" style="margin-top:10px;">
          <strong>Diagnostic rapide</strong>
          <ul class="list-tight" style="margin-top:8px;">
            ${hints.length
                    ? hints.map(h => `<li class="warn">${escapeHtml(h)}</li>`).join("")
                    : `<li class="ok">‚úÖ Rien d‚Äôanormal d√©tect√© (selon r√®gles actuelles)</li>`
                }
          </ul>
        </div>
      `;

            document.getElementById("btn-back-summary").onclick = () => showAnalysisSummary();
            document.getElementById("btn-highlight").onclick = () => highlightClassInDiagrams(className);
        }

        // -------------------------------------------------------------
        // HIGHLIGHT DIAGRAMS
        // -------------------------------------------------------------
        function clearDiagramHighlight() {
            const svgs = diagramContainerEl.querySelectorAll("svg");
            svgs.forEach(svg => {
                svg.querySelectorAll("*").forEach(el => {
                    el.style.opacity = "";
                    el.style.stroke = "";
                    el.style.strokeWidth = "";
                    el.style.filter = "";
                });
            });
        }

        function highlightClassInDiagrams(className) {
            clearDiagramHighlight();
            const svgs = diagramContainerEl.querySelectorAll("svg");

            svgs.forEach(svg => {
                const nodes = svg.querySelectorAll("g[class*='node']");
                nodes.forEach(node => {
                    const label = (node.textContent || "").trim();
                    const isMatch =
                        label === className ||
                        className.endsWith(`_${label}`) ||
                        normalizeClassName(label) === className;

                    if (isMatch) {
                        node.style.opacity = "1";
                        node.style.stroke = "#2563eb";
                        node.style.strokeWidth = "3px";
                        node.style.filter = "drop-shadow(0 0 6px #2563eb)";
                    } else {
                        node.style.opacity = "0.22";
                    }
                });
            });
        }

        // -------------------------------------------------------------
        // SUPER DIAGRAMS
        // -------------------------------------------------------------
        function buildSuperDiagramNamespace() {
            let out = "classDiagram\n    direction TB\n";

            const groups = { Server: [], Shared: [], Client: [] };
            for (const cls of Object.values(appState.classIndex)) {
                (groups[cls.namespace] || (groups.Shared)).push(cls.name);
            }

            for (const [ns, list] of Object.entries(groups)) {
                if (!list.length) continue;
                out += `  namespace ${ns} {\n`;
                list.sort().forEach(name => out += `    class ${name}\n`);
                out += "  }\n\n";
            }

            // Relations
            for (const cls of Object.values(appState.classIndex)) {
                cls.outgoing.forEach(rel => out += `  ${cls.name} --> ${rel}\n`);
            }

            return out;
        }

        function buildSuperDiagramType() {
            let out = "classDiagram\n    direction TB\n";

            const groups = {
                Manager: [], Handler: [], Container: [], Bootstrap: [],
                UI: [], Registry: [], Hub: [], Definition: [], Other: []
            };

            for (const cls of Object.values(appState.classIndex)) {
                (groups[cls.type] || groups.Other).push(cls.name);
            }

            for (const [type, list] of Object.entries(groups)) {
                if (!list.length) continue;
                out += `  namespace ${type} {\n`;
                list.sort().forEach(name => out += `    class ${name}\n`);
                out += "  }\n\n";
            }

            // Relations
            for (const cls of Object.values(appState.classIndex)) {
                cls.outgoing.forEach(rel => out += `  ${cls.name} --> ${rel}\n`);
            }

            return out;
        }

        // -------------------------------------------------------------
        // VUE COMBIN√âE
        // -------------------------------------------------------------
        function buildCombinedSummary(container) {
            const wrapper = document.createElement("div");
            wrapper.style.marginBottom = "12px";
            wrapper.innerHTML = `
        <div style="display:flex; align-items:center; justify-content:space-between; gap:8px; flex-wrap:wrap;">
          <div>
            <h3 style="margin:0;">Vue combin√©e ‚Äî Architecture compl√®te</h3>
            <div class="small-hint">Navigation rapide :</div>
          </div>
          <div style="display:flex; gap:8px; flex-wrap:wrap;">
            <button class="btn btn-primary" id="btn-combined-ns">Namespace</button>
            <button class="btn btn-primary" id="btn-combined-type">Type</button>
            <button class="btn btn-primary" id="btn-combined-doc">Docs</button>
            <button class="btn btn-primary" id="btn-combined-analysis">Analyse</button>
          </div>
        </div>
      `;
            container.appendChild(wrapper);
            return wrapper;
        }

        // -------------------------------------------------------------
        // SELECT VIEW
        // -------------------------------------------------------------
        async function selectView(viewKey) {
            document.querySelectorAll(".nav-item").forEach(el => {
                el.classList.toggle("active", el.dataset.viewKey === viewKey);
            });

            clearDiagramHighlight();
            diagramContainerEl.innerHTML = "";
            analysisContainerEl.innerHTML = "";

            const g = appState.graph;
            const pill = g ? `<span class="pill">${g.n} classes ‚Ä¢ ${g.edgeCount} liens</span>` : "";

            if (viewKey === "fusion-doc") {
                currentViewTitleEl.innerHTML = `Fusion documentaire ‚Äî Tous les fichiers ${pill}`;

                const fusionContainer = document.createElement("div");
                diagramContainerEl.appendChild(fusionContainer);

                for (const file of appState.files) {
                    const title = document.createElement("h3");
                    title.textContent = file.name;
                    title.style.margin = "10px 0 6px 0";
                    fusionContainer.appendChild(title);

                    const blocks = extractMermaidBlocks(file.content);
                    if (!blocks.length) {
                        const msg = document.createElement("p");
                        msg.className = "small-hint";
                        msg.textContent = "Aucun diagramme Mermaid trouv√©.";
                        fusionContainer.appendChild(msg);
                        continue;
                    }

                    for (const block of blocks) {
                        await renderMermaidDiagram(block, fusionContainer);
                    }
                }

                showAnalysisSummary();
                return;
            }

            if (viewKey.startsWith("file:")) {
                const filename = viewKey.substring("file:".length);
                const file = appState.files.find(f => f.name === filename);

                if (!file) {
                    diagramContainerEl.innerHTML = "<p class='small-hint' style='padding:12px;'>Fichier introuvable.</p>";
                    showAnalysisSummary();
                    return;
                }

                currentViewTitleEl.innerHTML = `Fichier : ${escapeHtml(filename)} ${pill}`;

                const blocks = extractMermaidBlocks(file.content);

                if (!blocks.length) {
                    diagramContainerEl.innerHTML = `
            <div style="padding:12px;">
              <p class="small-hint">Aucun bloc Mermaid trouv√©. Contenu brut :</p>
              <pre class="mono">${escapeHtml(file.content)}</pre>
            </div>
          `;
                    showAnalysisSummary();
                    return;
                }

                for (const block of blocks) {
                    await renderMermaidDiagram(block, diagramContainerEl);
                }

                showAnalysisSummary();
                return;
            }

            if (viewKey === "super-ns") {
                currentViewTitleEl.innerHTML = `Super-diagramme (par namespace) ${pill}`;
                await renderMermaidDiagram(buildSuperDiagramNamespace(), diagramContainerEl);
                showAnalysisSummary();
                return;
            }

            if (viewKey === "super-type") {
                currentViewTitleEl.innerHTML = `Super-diagramme (par type) ${pill}`;
                await renderMermaidDiagram(buildSuperDiagramType(), diagramContainerEl);
                showAnalysisSummary();
                return;
            }

            if (viewKey === "combined") {
                currentViewTitleEl.innerHTML = `Vue combin√©e ‚Äî Architecture compl√®te ${pill}`;
                diagramContainerEl.innerHTML = "";

                buildCombinedSummary(diagramContainerEl);

                const main = document.createElement("div");
                main.style.display = "flex";
                main.style.flexDirection = "column";
                main.style.gap = "30px";
                diagramContainerEl.appendChild(main);

                // 1) Namespace
                const nsBlock = document.createElement("div");
                nsBlock.innerHTML = "<h3 style='margin:0 0 6px 0;'>Super-diagramme (Namespace)</h3>";
                main.appendChild(nsBlock);
                await renderMermaidDiagram(buildSuperDiagramNamespace(), nsBlock);

                // 2) Type
                const typeBlock = document.createElement("div");
                typeBlock.innerHTML = "<h3 style='margin:0 0 6px 0;'>Super-diagramme (Type)</h3>";
                main.appendChild(typeBlock);
                await renderMermaidDiagram(buildSuperDiagramType(), typeBlock);

                // 3) Docs
                const docBlock = document.createElement("div");
                docBlock.innerHTML = "<h3 style='margin:0 0 6px 0;'>Fusion documentaire</h3>";
                main.appendChild(docBlock);

                for (const file of appState.files) {
                    const title = document.createElement("h4");
                    title.textContent = file.name;
                    title.style.margin = "12px 0 6px 0";
                    docBlock.appendChild(title);

                    const blocks = extractMermaidBlocks(file.content);
                    for (const block of blocks) {
                        await renderMermaidDiagram(block, docBlock);
                    }
                }

                // 4) Analyse (on la met dans panneau analyse)
                const analysisBlock = document.createElement("div");
                analysisBlock.innerHTML = "<h3 style='margin:0 0 6px 0;'>Analyse (voir panneau √† droite)</h3>";
                main.appendChild(analysisBlock);
                showAnalysisSummary();

                // Scroll buttons
                document.getElementById("btn-combined-ns").onclick = () => nsBlock.scrollIntoView({ behavior: "smooth" });
                document.getElementById("btn-combined-type").onclick = () => typeBlock.scrollIntoView({ behavior: "smooth" });
                document.getElementById("btn-combined-doc").onclick = () => docBlock.scrollIntoView({ behavior: "smooth" });
                document.getElementById("btn-combined-analysis").onclick = () => analysisPanel.scrollIntoView({ behavior: "smooth" });

                return;
            }
        }

        // -------------------------------------------------------------
        // CHOIX DOSSIER
        // -------------------------------------------------------------
        async function handleChooseFolder() {
            if (!isFileSystemAPISupported()) {
                alert("Ton navigateur ne supporte pas showDirectoryPicker. Utilise Chrome/Edge.");
                return;
            }

            try {
                const directoryHandle = await window.showDirectoryPicker();
                appState.directoryHandle = directoryHandle;
                appState.files = [];

                folderStatusEl.textContent = "Chargement des fichiers .md...";
                toolbarInfoEl.textContent = "Lecture du dossier en cours...";

                for await (const entry of directoryHandle.values()) {
                    if (entry.kind === "file" && entry.name.toLowerCase().endsWith(".md")) {
                        const file = await entry.getFile();
                        const content = await file.text();
                        appState.files.push({ name: entry.name, content });
                    }
                }

                if (!appState.files.length) {
                    folderStatusEl.textContent = "Aucun fichier .md trouv√©.";
                    toolbarInfoEl.textContent = "Dossier charg√©, mais vide.";
                    diagramContainerEl.innerHTML = "<p class='small-hint' style='padding:12px;'>Aucun fichier .md trouv√©.</p>";
                    viewsListEl.innerHTML = "";
                    classShortcutsEl.innerHTML = "";
                    analysisContainerEl.innerHTML = "<p class='small-hint'>Rien √† analyser.</p>";
                    return;
                }

                // Sort files
                appState.files.sort((a, b) => a.name.localeCompare(b.name));

                folderStatusEl.textContent = `${appState.files.length} fichier(s) .md trouv√©(s).`;
                toolbarInfoEl.textContent = "Dossier charg√©. S√©lectionne une vue.";

                // build graph + UI
                buildGraphIndex();
                initializeViewsFromFiles();

            } catch (err) {
                if (err && err.name === "AbortError") {
                    folderStatusEl.textContent = "Choix annul√©.";
                    toolbarInfoEl.textContent = "Aucun dossier charg√©.";
                    return;
                }
                console.error("Erreur lors du choix du dossier :", err);
                folderStatusEl.textContent = "Erreur lors du choix du dossier.";
                toolbarInfoEl.textContent = "Erreur lors du chargement.";
            }
        }

        // -------------------------------------------------------------
        // FOCUS MODE
        // -------------------------------------------------------------
        function toggleFocusMode() {
            appState.focusMode = !appState.focusMode;

            if (appState.focusMode) {
                // On cache analyse et on passe diagram full
                analysisPanel.style.display = "none";
                contentEl.style.gridTemplateColumns = "1fr";
                btnFocus.textContent = "‚Ü©Ô∏è Quitter focus";
            } else {
                analysisPanel.style.display = "";
                contentEl.style.gridTemplateColumns = "2fr 1fr";
                btnFocus.textContent = "üß† Focus diagramme";
            }
        }

        // -------------------------------------------------------------
        // INIT
        // -------------------------------------------------------------
        chooseFolderBtn.addEventListener("click", handleChooseFolder);
        btnFocus.addEventListener("click", toggleFocusMode);

        console.log("App ready.");
    </script>
</body>

</html>
