<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8" />
    <title>Explorer Architecture Client / Serveur</title>

    <!-- Mermaid pour les diagrammes -->
    <script type="module">
        import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
        mermaid.initialize({
            startOnLoad: false,
            theme: "default"
        });
        window.mermaid = mermaid;
    </script>

    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            display: flex;
            height: 100vh;
            color: #111827;
            background: #f3f4f6;
        }

        #sidebar {
            width: 280px;
            background: #111827;
            color: #e5e7eb;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        #sidebar h1 {
            margin: 0;
            font-size: 1.2rem;
            color: #f9fafb;
        }

        #sidebar p {
            margin: 4px 0 0 0;
            font-size: 0.8rem;
            color: #9ca3af;
        }

        #main {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        #toolbar {
            padding: 8px 12px;
            background: #ffffff;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #content {
            flex: 1;
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 0;
            height: calc(100vh - 48px);
        }

        #diagram-panel {
            border-right: 1px solid #e5e7eb;
            padding: 12px 16px;
            overflow: auto;
            background: #f9fafb;
        }

        #diagram-container {
            overflow-y: auto;
            max-height: calc(100vh - 100px);
        }

        #analysis-panel {
            padding: 12px 16px;
            overflow: auto;
            background: #ffffff;
        }

        .section-title {
            margin: 0 0 8px 0;
            font-size: 1rem;
        }

        .nav-section-title {
            margin: 12px 0 4px 0;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            color: #9ca3af;
        }

        button {
            font-family: inherit;
        }

        .btn {
            border: none;
            border-radius: 6px;
            padding: 6px 10px;
            font-size: 0.85rem;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .btn-primary {
            background: #2563eb;
            color: #f9fafb;
        }

        .btn-primary:hover {
            background: #1d4ed8;
        }

        .btn-ghost {
            background: transparent;
            color: #e5e7eb;
        }

        .btn-ghost:hover {
            background: #1f2937;
        }

        .nav-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .nav-item {
            border-radius: 6px;
            padding: 6px 8px;
            font-size: 0.85rem;
            cursor: pointer;
        }

        .nav-item:hover {
            background: #1f2937;
        }

        .nav-item.active {
            background: #2563eb;
            color: #f9fafb;
        }

        #current-view-title {
            font-size: 0.95rem;
            font-weight: 600;
            margin-bottom: 8px;
        }

        #diagram-container {
            border-radius: 8px;
            background: #ffffff;
            padding: 8px;
            min-height: 200px;
        }

        #analysis-container {
            border-radius: 8px;
            background: #f9fafb;
            padding: 8px;
        }

        .small-hint {
            font-size: 0.8rem;
            color: #6b7280;
        }
    </style>
</head>

<body>
    <aside id="sidebar">
        <div>
            <h1>Explorer Architecture</h1>
            <p>Client / Serveur / Shared ‚Ä¢ Sessions ‚Ä¢ Jeux</p>
        </div>

        <div>
            <div class="nav-section-title">Chargement</div>
            <button class="btn btn-ghost" id="choose-folder-btn">
                üìÅ Choisir un dossier de .md
            </button>
            <p class="small-hint">
                Le dossier doit contenir les fichiers Mermaid (<code>.md</code>) avec tes diagrammes.
            </p>
            <div id="folder-status" class="small-hint"></div>
        </div>

        <div>
            <div class="nav-section-title">Vues disponibles</div>
            <div id="views-list" class="nav-list">
                <!-- Les vues (use case, classes, composants, etc.) seront ajout√©es ici en JS -->
            </div>
        </div>

        <div>
            <div class="nav-section-title">Navigation classes</div>
            <div id="class-shortcuts" class="nav-list">
                <!-- Raccourcis de classes importants ajout√©s dynamiquement -->
            </div>
        </div>
    </aside>

    <main id="main">
        <div id="toolbar">
            <div id="toolbar-info" class="small-hint">
                Aucun dossier charg√©. Choisis un dossier de fichiers <code>.md</code> pour commencer.
            </div>
        </div>

        <div id="content">
            <section id="diagram-panel">
                <h2 class="section-title">Diagramme / Vue</h2>
                <div id="current-view-title">Aucune vue s√©lectionn√©e</div>
                <div id="diagram-container">
                    <p class="small-hint">
                        Une fois le dossier charg√©, tu pourras s√©lectionner un diagramme ou une vue fusionn√©e ici.
                    </p>
                </div>
            </section>

            <aside id="analysis-panel">
                <h2 class="section-title">Analyse & d√©tails</h2>
                <div id="analysis-container">
                    <p class="small-hint">
                        Cette zone affichera :
                    </p>
                    <ul class="small-hint">
                        <li><strong>Patterns d√©tect√©s</strong> (Managers, Handlers, Containers, Hub, Bootstrap...)</li>
                        <li><strong>Points communs</strong> entre classes et composants</li>
                        <li><strong>Incoh√©rences potentielles</strong> (couplage, circularit√©, etc.)</li>
                        <li><strong>D√©tails d'une classe</strong> lorsque tu la s√©lectionnes</li>
                    </ul>
                </div>
            </aside>
        </div>
    </main>

    <!-- Scripts viendront ici dans les parties suivantes -->
    <script>
        // --- √âtat global minimal ---
        const appState = {
            directoryHandle: null,
            files: [], // { name, content }
        };

        const chooseFolderBtn = document.getElementById("choose-folder-btn");
        const folderStatusEl = document.getElementById("folder-status");
        const toolbarInfoEl = document.getElementById("toolbar-info");
        const viewsListEl = document.getElementById("views-list");
        const diagramContainerEl = document.getElementById("diagram-container");
        const currentViewTitleEl = document.getElementById("current-view-title");
        const analysisContainerEl = document.getElementById("analysis-container");
        const classShortcutsEl = document.getElementById("class-shortcuts");

        console.log("Squelette de base charg√©.");

        // V√©rifie si l'API File System Access est disponible
        function isFileSystemAPISupported() {
            return "showDirectoryPicker" in window;
        }

        async function handleChooseFolder() {
            if (!isFileSystemAPISupported()) {
                alert("Votre navigateur ne supporte pas showDirectoryPicker. Utilise Chrome ou Edge.");
                return;
            }

            try {
                const directoryHandle = await window.showDirectoryPicker();
                appState.directoryHandle = directoryHandle;
                appState.files = [];

                folderStatusEl.textContent = "Chargement des fichiers .md...";
                toolbarInfoEl.textContent = "Lecture du dossier en cours...";

                for await (const entry of directoryHandle.values()) {
                    if (entry.kind === "file" && entry.name.toLowerCase().endsWith(".md")) {
                        const file = await entry.getFile();
                        const content = await file.text();
                        appState.files.push({
                            name: entry.name,
                            content
                        });
                    }
                }

                if (appState.files.length === 0) {
                    folderStatusEl.textContent = "Aucun fichier .md trouv√©.";
                    toolbarInfoEl.textContent = "Dossier charg√©, mais vide.";
                    diagramContainerEl.innerHTML = "<p class='small-hint'>Aucun fichier .md trouv√©.</p>";
                    viewsListEl.innerHTML = "";
                    classShortcutsEl.innerHTML = "";
                    return;
                }

                folderStatusEl.textContent = `${appState.files.length} fichier(s) .md trouv√©(s).`;
                toolbarInfoEl.textContent = "Dossier charg√©. S√©lectionne une vue.";

                initializeViewsFromFiles();

            } catch (err) {
                console.error("Erreur lors du choix du dossier :", err);
                folderStatusEl.textContent = "Erreur lors du choix du dossier.";
                toolbarInfoEl.textContent = "Erreur lors du chargement.";
            }
        }

        // Cr√©ation d'une premi√®re vue brute bas√©e sur les fichiers disponibles
        function initializeViewsFromFiles() {
            viewsListEl.innerHTML = "";

            // Vue sp√©ciale "Fusion documentaire"
            const fusionItem = document.createElement("div");
            fusionItem.className = "nav-item";
            fusionItem.textContent = "Fusion documentaire (tous les fichiers)";
            fusionItem.dataset.viewKey = "fusion-doc";
            fusionItem.addEventListener("click", () => selectView("fusion-doc"));
            viewsListEl.appendChild(fusionItem);

            // Une vue par fichier
            appState.files.forEach(file => {
                const item = document.createElement("div");
                item.className = "nav-item";
                item.textContent = file.name;
                item.dataset.viewKey = `file:${file.name}`;
                item.addEventListener("click", () => selectView(`file:${file.name}`));
                viewsListEl.appendChild(item);
            });

            diagramContainerEl.innerHTML = "<p class='small-hint'>S√©lectionne une vue.</p>";
            currentViewTitleEl.textContent = "Aucune vue s√©lectionn√©e";

            classShortcutsEl.innerHTML = "<div class='small-hint'>Les classes appara√Ætront apr√®s analyse.</div>";

            analysisContainerEl.innerHTML = `
            <p class="small-hint">
                Les fichiers ont √©t√© charg√©s. S√©lectionne une vue pour afficher les diagrammes.
            </p>
        `;
        }
        // Ajout des vues super-diagrammes dans le menu
        function addSuperDiagramViews() {
            const nsItem = document.createElement("div");
            nsItem.className = "nav-item";
            nsItem.textContent = "Super-diagramme (par namespace)";
            nsItem.dataset.viewKey = "super-ns";
            nsItem.addEventListener("click", () => selectView("super-ns"));
            viewsListEl.appendChild(nsItem);

            const typeItem = document.createElement("div");
            typeItem.className = "nav-item";
            typeItem.textContent = "Super-diagramme (par type)";
            typeItem.dataset.viewKey = "super-type";
            typeItem.addEventListener("click", () => selectView("super-type"));
            viewsListEl.appendChild(typeItem);
        }
        function addCombinedView() {
            const item = document.createElement("div");
            item.className = "nav-item";
            item.textContent = "Vue combin√©e (Architecture compl√®te)";
            item.dataset.viewKey = "combined";
            item.addEventListener("click", () => selectView("combined"));
            viewsListEl.appendChild(item);
        }

        // √âtendre initializeViewsFromFiles pour ajouter la vue combin√©e
        const oldInitViews2 = initializeViewsFromFiles;
        initializeViewsFromFiles = function () {
            oldInitViews2();
            addCombinedView();
        };
        // On √©tend initializeViewsFromFiles pour ajouter ces vues
        const oldInitViews = initializeViewsFromFiles;
        initializeViewsFromFiles = function () {
            oldInitViews();
            addSuperDiagramViews();
        };
        // --- Extraction des blocs Mermaid ---
        function extractMermaidBlocks(mdText) {
            const blocks = [];
            const regex = /```mermaid([\s\S]*?)```/g;
            let match;

            while ((match = regex.exec(mdText)) !== null) {
                blocks.push(match[1].trim());
            }

            return blocks;
        }

        // --- Rendu d'un diagramme Mermaid ---
     async function renderMermaidDiagram(code, container) {
    try {
        if (!window.mermaid || typeof window.mermaid.render !== "function") {
            throw new Error("Mermaid n'est pas encore charg√©.");
        }

        const id = "mmd_" + Math.random().toString(36).substring(2, 10);
        const { svg } = await window.mermaid.render(id, code);
        const wrapper = document.createElement("div");
        wrapper.innerHTML = svg;
        wrapper.style.margin = "24px 0";
        wrapper.style.padding = "12px";
        wrapper.style.background = "#fff";
        wrapper.style.borderRadius = "8px";
        wrapper.style.boxShadow = "0 0 4px rgba(0,0,0,0.05)";
        container.appendChild(wrapper);
    } catch (err) {
        console.error("Erreur Mermaid :", err);
        const errorBox = document.createElement("pre");
        errorBox.style.color = "red";
        errorBox.textContent = "Erreur Mermaid : " + err.message;
        container.appendChild(errorBox);
    }
}
function addDiagramLabel(container, text = "Diagramme Mermaid") {
    const p = document.createElement("p");
    p.textContent = text;
    p.className = "small-hint";
    container.appendChild(p);
}

        // --- S√©lection d'une vue ---
        async function selectView(viewKey) {
            document.querySelectorAll(".nav-item").forEach(el => {
                el.classList.toggle("active", el.dataset.viewKey === viewKey);
            });

            diagramContainerEl.innerHTML = "";
            analysisContainerEl.innerHTML = "";

            if (viewKey === "fusion-doc") {
                currentViewTitleEl.textContent = "Fusion documentaire - Tous les fichiers";

                const fusionContainer = document.createElement("div");
                diagramContainerEl.appendChild(fusionContainer);

                for (const file of appState.files) {
                    const title = document.createElement("h3");
                    title.textContent = file.name;
                    fusionContainer.appendChild(title);

                    const blocks = extractMermaidBlocks(file.content);

                    if (blocks.length === 0) {
                        const msg = document.createElement("p");
                        msg.textContent = "Aucun diagramme Mermaid trouv√©.";
                        fusionContainer.appendChild(msg);
                        continue;
                    }

                    for (const block of blocks) {
                        addDiagramLabel(fusionContainer);
                        await renderMermaidDiagram(block, fusionContainer);
                    }
                }

                return;
            }

            if (viewKey.startsWith("file:")) {
                const filename = viewKey.substring("file:".length);
                const file = appState.files.find(f => f.name === filename);

                if (!file) {
                    diagramContainerEl.innerHTML = "<p class='small-hint'>Fichier introuvable.</p>";
                    return;
                }

                currentViewTitleEl.textContent = `Fichier : ${filename}`;

                const blocks = extractMermaidBlocks(file.content);

                if (blocks.length === 0) {
                    diagramContainerEl.innerHTML = `
                    <p class="small-hint">Aucun diagramme Mermaid trouv√©.</p>
                    <pre style="white-space:pre-wrap;font-size:0.8rem;background:#f3f4f6;padding:8px;border-radius:6px;">
${escapeHtml(file.content)}
                    </pre>
                `;
                    return;
                }

                for (const block of blocks) {
                    addDiagramLabel(diagramContainerEl);
                    await renderMermaidDiagram(block, diagramContainerEl);
                }

                return;
            }
            // Vue super-diagramme par namespace
            if (viewKey === "super-ns") {
                currentViewTitleEl.textContent = "Super-diagramme (par namespace)";
                const code = buildSuperDiagramNamespace();
                addDiagramLabel(diagramContainerEl);
                await renderMermaidDiagram(code, diagramContainerEl);
                return;
            }

            // Vue super-diagramme par type
            if (viewKey === "super-type") {
                currentViewTitleEl.textContent = "Super-diagramme (par type)";
                const code = buildSuperDiagramType();
                addDiagramLabel(diagramContainerEl);
                await renderMermaidDiagram(code, diagramContainerEl);
                return;
            }
            // Vue combin√©e
            if (viewKey === "combined") {
                currentViewTitleEl.textContent = "Vue combin√©e ‚Äî Architecture compl√®te";
                diagramContainerEl.innerHTML = "";

                // Sommaire
                const summary = buildCombinedSummary(diagramContainerEl);

                // Conteneur principal
                const main = document.createElement("div");
                main.style.display = "flex";
                main.style.flexDirection = "column";
                main.style.gap = "40px";
                diagramContainerEl.appendChild(main);

                // 1. Super-diagramme Namespace
                const nsBlock = document.createElement("div");
                nsBlock.innerHTML = "<h3>Super-diagramme (Namespace)</h3>";
                main.appendChild(nsBlock);
          addDiagramLabel(nsBlock);
await renderMermaidDiagram(buildSuperDiagramNamespace(), nsBlock);

                // 2. Super-diagramme Type
                const typeBlock = document.createElement("div");
                typeBlock.innerHTML = "<h3>Super-diagramme (Type)</h3>";
                main.appendChild(typeBlock);
                addDiagramLabel(typeBlock);
await renderMermaidDiagram(buildSuperDiagramType(), typeBlock);
                await renderMermaidDiagram(buildSuperDiagramType(), typeBlock);

                // 3. Fusion documentaire
                const docBlock = document.createElement("div");
                docBlock.innerHTML = "<h3>Fusion documentaire</h3>";
                main.appendChild(docBlock);

                for (const file of appState.files) {
                    const title = document.createElement("h4");
                    title.textContent = file.name;
                    docBlock.appendChild(title);

                    const blocks = extractMermaidBlocks(file.content);
                    for (const block of blocks) {
                 addDiagramLabel(docBlock);
await renderMermaidDiagram(block, docBlock);
                    }
                }

                // 4. Analyse avanc√©e
                const analysisBlock = document.createElement("div");
                analysisBlock.innerHTML = "<h3>Analyse avanc√©e</h3>";
                main.appendChild(analysisBlock);

                const issues = runAdvancedAnalysis();
                analysisBlock.innerHTML += `
        <ul>
            ${issues.map(i => `<li>${i}</li>`).join("")}
        </ul>
    `;

                // Navigation interne
                document.getElementById("btn-combined-ns").onclick = () => {
                    nsBlock.scrollIntoView({ behavior: "smooth" });
                };
                document.getElementById("btn-combined-type").onclick = () => {
                    typeBlock.scrollIntoView({ behavior: "smooth" });
                };
                document.getElementById("btn-combined-doc").onclick = () => {
                    docBlock.scrollIntoView({ behavior: "smooth" });
                };
                document.getElementById("btn-combined-analysis").onclick = () => {
                    analysisBlock.scrollIntoView({ behavior: "smooth" });
                };

                return;
            }
        }

        function escapeHtml(str) {
            return str
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;");
        }

        chooseFolderBtn.addEventListener("click", handleChooseFolder);

        // -------------------------------------------------------------
        // BLOC 4 ‚Äî Analyse des classes + patterns + raccourcis
        // -------------------------------------------------------------

        // Base de donn√©es interne des classes
        appState.classIndex = {};
        // Structure :
        // {
        //   ClassName: {
        //      name: "ClassName",
        //      files: ["class_diagram.md"],
        //      relations: [],
        //      type: "Manager" | "Handler" | "Container" | "UI" | "Bootstrap" | "Registry" | "Hub" | "Definition" | "Other",
        //      namespace: "Server" | "Shared" | "Client" | "Unknown"
        //   }
        // }

        // D√©tection des classes dans un diagramme Mermaid classDiagram
        function extractClassesFromClassDiagram(code) {
            const classes = [];
            const regex = /class\s+([A-Za-z0-9_]+)/g;
            let match;

            while ((match = regex.exec(code)) !== null) {
                classes.push(match[1]);
            }

            return classes;
        }

        // D√©tection des relations (A --> B, A *-- B, etc.)
        function extractRelationsFromClassDiagram(code) {
            const relations = [];
            const regex = /([A-Za-z0-9_]+)\s+[-.*o]+[->]+\s+([A-Za-z0-9_]+)/g;
            let match;

            while ((match = regex.exec(code)) !== null) {
                relations.push({
                    from: match[1],
                    to: match[2]
                });
            }

            return relations;
        }

        // D√©tection du namespace (Server / Shared / Client)
        function detectNamespace(className) {
            if (/Server/i.test(className)) return "Server";
            if (/Client/i.test(className)) return "Client";
            return "Shared";
        }

        // D√©tection du type (pattern)
        function detectClassType(className) {
            if (/Manager$/i.test(className)) return "Manager";
            if (/Handler$/i.test(className)) return "Handler";
            if (/Container$/i.test(className)) return "Container";
            if (/Bootstrap$/i.test(className)) return "Bootstrap";
            if (/UI$/i.test(className) || /UIController$/i.test(className)) return "UI";
            if (/Registry$/i.test(className)) return "Registry";
            if (/Hub$/i.test(className)) return "Hub";
            if (/Definition$/i.test(className)) return "Definition";
            return "Other";
        }

        // Analyse compl√®te des fichiers
        function analyzeAllFiles() {
            appState.classIndex = {};

            for (const file of appState.files) {
                const blocks = extractMermaidBlocks(file.content);

                for (const block of blocks) {
                    if (!block.includes("classDiagram")) continue;

                    const classes = extractClassesFromClassDiagram(block);
                    const relations = extractRelationsFromClassDiagram(block);

                    // Ajout des classes
                    for (const cls of classes) {
                        if (!appState.classIndex[cls]) {
                            appState.classIndex[cls] = {
                                name: cls,
                                files: [],
                                relations: [],
                                type: detectClassType(cls),
                                namespace: detectNamespace(cls)
                            };
                        }
                        appState.classIndex[cls].files.push(file.name);
                    }

                    // Ajout des relations
                    for (const rel of relations) {
                        if (appState.classIndex[rel.from]) {
                            appState.classIndex[rel.from].relations.push(rel.to);
                        }
                    }
                }
            }

            generateClassShortcuts();
            showAnalysisSummary();
        }

        // G√©n√©ration des raccourcis de classes dans la sidebar
        function generateClassShortcuts() {
            classShortcutsEl.innerHTML = "";

            const groups = {
                Manager: [],
                Handler: [],
                Container: [],
                Bootstrap: [],
                UI: [],
                Registry: [],
                Hub: [],
                Definition: [],
                Other: []
            };

            for (const cls of Object.values(appState.classIndex)) {
                groups[cls.type].push(cls);
            }

            for (const [type, list] of Object.entries(groups)) {
                if (list.length === 0) continue;

                const title = document.createElement("div");
                title.className = "nav-section-title";
                title.textContent = type;
                classShortcutsEl.appendChild(title);

                for (const cls of list) {
                    const item = document.createElement("div");
                    item.className = "nav-item";
                    item.textContent = cls.name;
                    item.addEventListener("click", () => showClassDetails(cls.name));
                    classShortcutsEl.appendChild(item);
                }
            }
        }

        // Affichage des d√©tails d‚Äôune classe
        function showClassDetails(className) {
            const cls = appState.classIndex[className];
            if (!cls) return;

            analysisContainerEl.innerHTML = `
        <h3>${cls.name}</h3>
        <p><strong>Type :</strong> ${cls.type}</p>
        <p><strong>Namespace :</strong> ${cls.namespace}</p>

        <p><strong>Fichiers :</strong></p>
        <ul>${cls.files.map(f => `<li>${f}</li>`).join("")}</ul>

        <p><strong>Relations :</strong></p>
        <ul>${cls.relations.map(r => `<li>${r}</li>`).join("") || "<li>Aucune</li>"}</ul>
    `;
        }

        // R√©sum√© global de l‚Äôanalyse
        function showAnalysisSummary() {
            const total = Object.keys(appState.classIndex).length;

            analysisContainerEl.innerHTML = `
        <h3>Analyse globale</h3>
        <p><strong>${total}</strong> classes d√©tect√©es.</p>

        <p><strong>R√©partition par type :</strong></p>
        <ul>
            ${Object.entries(
                Object.groupBy(Object.values(appState.classIndex), c => c.type)
            ).map(([type, list]) => `<li>${type} : ${list.length}</li>`).join("")}
        </ul>
    `;
        }

        // On d√©clenche l‚Äôanalyse apr√®s chargement des fichiers
        const originalInitializeViews = initializeViewsFromFiles;
        initializeViewsFromFiles = function () {
            originalInitializeViews();
            analyzeAllFiles();
        };

        // -------------------------------------------------------------
        // BLOC 5 ‚Äî Navigation intelligente + highlight dans les diagrammes
        // -------------------------------------------------------------

        // R√©initialise le highlight dans tous les diagrammes
        function clearDiagramHighlight() {
            const svgElements = diagramContainerEl.querySelectorAll("svg");
            svgElements.forEach(svg => {
                svg.querySelectorAll("*").forEach(el => {
                    el.style.opacity = "";
                    el.style.stroke = "";
                    el.style.strokeWidth = "";
                    el.style.filter = "";
                });
            });
        }

        // Applique un highlight sur une classe dans tous les diagrammes
        function highlightClassInDiagrams(className) {
            clearDiagramHighlight();

            const svgElements = diagramContainerEl.querySelectorAll("svg");

            svgElements.forEach(svg => {
                const nodes = svg.querySelectorAll("g[class*='node']");

                let found = false;

                nodes.forEach(node => {
                    const label = node.textContent.trim();

                    if (label === className) {
                        found = true;

                        // Highlight
                        node.style.opacity = "1";
                        node.style.stroke = "#2563eb";
                        node.style.strokeWidth = "3px";
                        node.style.filter = "drop-shadow(0 0 6px #2563eb)";
                    } else {
                        // Fade out
                        node.style.opacity = "0.25";
                    }
                });

                // Si aucun node trouv√©, on ne fait rien
            });
        }

        // On modifie showClassDetails pour activer le highlight
        const originalShowClassDetails = showClassDetails;
        showClassDetails = function (className) {
            originalShowClassDetails(className);
            highlightClassInDiagrams(className);
        };

        // Quand on change de vue ‚Üí reset highlight
        const originalSelectView = selectView;
// -------------------------------------------------------------
// BLOC ‚Äî Correcteur automatique Mermaid
// -------------------------------------------------------------

function fixMermaidCode(code) {
    let fixed = code;

    // 1. Supprimer les directives PlantUML
    fixed = fixed.replace(/^\s*!include.*$/gmi, "");
    fixed = fixed.replace(/^\s*puml\s*$/gmi, "");
    fixed = fixed.replace(/@startuml|@enduml/gmi, "");

    // 2. Remplacer les noms contenant des points (Server.Class ‚Üí Server_Class)
    fixed = fixed.replace(/([A-Za-z0-9]+)\.([A-Za-z0-9]+)/g, "$1_$2");

    // 3. Corriger les notes PlantUML ‚Üí notes Mermaid
    fixed = fixed.replace(/note\s+"([^"]+)"\s*$/gmi, "note right\n$1\nend note");
    fixed = fixed.replace(/note\s+for\s+([A-Za-z0-9_]+)\s+"([^"]+)"/gmi,
        "note right of $1\n$2\nend note");

    // 4. Corriger les labels flowchart contenant des ":" interdits
    fixed = fixed.replace(/--\s*"([^"]+):([^"]+)"\s*-->/g,
        '-- "$1 - $2" -->');

    // 5. Corriger les noms de classes avec des caract√®res interdits
    fixed = fixed.replace(/[^\w\s\-\>\:\.\{\}\(\)\[\]"]/g, "");

    // 6. Supprimer les lignes C4-PlantUML non support√©es
    if (/C4Component|Container_Boundary|Component|Rel\(/.test(fixed)) {
        return "// Diagramme C4 non support√© par Mermaid";
    }

    return fixed.trim();
}
        selectView = async function (viewKey) {

            await originalSelectView(viewKey);
            clearDiagramHighlight();
        };
        // G√©n√®re un super-diagramme classDiagram regroup√© par namespace
        function buildSuperDiagramNamespace() {
            let out = "classDiagram\n";

            const groups = {
                Server: [],
                Shared: [],
                Client: [],
                Unknown: []
            };

            for (const cls of Object.values(appState.classIndex)) {
                groups[cls.namespace].push(cls.name);
            }

            for (const [ns, list] of Object.entries(groups)) {
                if (list.length === 0) continue;
                out += `    namespace ${ns} {\n`;
                for (const name of list) {
                    out += `        class ${name}\n`;
                }
                out += "    }\n\n";
            }

            for (const cls of Object.values(appState.classIndex)) {
                for (const rel of cls.relations) {
                    out += `    ${cls.name} --> ${rel}\n`;
                }
            }

            return out;
        }
        // G√©n√®re un super-diagramme classDiagram regroup√© par type
        function buildSuperDiagramType() {
            let out = "classDiagram\n";

            const groups = {
                Manager: [],
                Handler: [],
                Container: [],
                Bootstrap: [],
                UI: [],
                Registry: [],
                Hub: [],
                Definition: [],
                Other: []
            };

            for (const cls of Object.values(appState.classIndex)) {
                groups[cls.type].push(cls.name);
            }

            for (const [type, list] of Object.entries(groups)) {
                if (list.length === 0) continue;
                out += `    namespace ${type} {\n`;
                for (const name of list) {
                    out += `        class ${name}\n`;
                }
                out += "    }\n\n";
            }

            // Ajout des relations
            for (const cls of Object.values(appState.classIndex)) {
                for (const rel of cls.relations) {
                    out += `    ${cls.name} --> ${rel}\n`;
                }
            }

            return out;
        }
        function buildCombinedSummary(container) {
            container.style.overflowY = "auto";
            container.style.maxHeight = "calc(100vh - 100px)";

            const wrapper = document.createElement("div");
            wrapper.style.marginBottom = "20px";
            wrapper.innerHTML = `
        <h3>Vue combin√©e ‚Äî Architecture compl√®te</h3>
        <p class="small-hint">Navigation rapide :</p>
        <div style="display:flex; gap:8px; flex-wrap:wrap;">
            <button class="btn btn-primary" id="btn-combined-ns">Super-diagramme Namespace</button>
            <button class="btn btn-primary" id="btn-combined-type">Super-diagramme Type</button>
            <button class="btn btn-primary" id="btn-combined-doc">Fusion documentaire</button>
            <button class="btn btn-primary" id="btn-combined-analysis">Analyse avanc√©e</button>
        </div>
    `;
            container.appendChild(wrapper);

            return wrapper;
        }
        // -------------------------------------------------------------
        // BLOC 7 ‚Äî Analyse avanc√©e (C3) : incoh√©rences, circularit√©, etc.
        // -------------------------------------------------------------
        function runAdvancedAnalysis() {
            const issues = [];

            for (const cls of Object.values(appState.classIndex)) {
                if (cls.relations.length > 8) {
                    issues.push(`‚ö†Ô∏è ${cls.name} a ${cls.relations.length} relations ‚Äî possible surcouplage.`);
                }
                if (cls.relations.length === 0) {
                    issues.push(`‚ö†Ô∏è ${cls.name} n'a aucune relation ‚Äî possible classe orpheline.`);
                }
            }

            // D√©tection de circularit√© simple
            for (const cls of Object.values(appState.classIndex)) {
                for (const rel of cls.relations) {
                    const target = appState.classIndex[rel];
                    if (target && target.relations.includes(cls.name)) {
                        issues.push(`üîÅ D√©pendance circulaire entre ${cls.name} et ${rel}.`);
                    }
                }
            }

            // Handlers sans manager
            for (const cls of Object.values(appState.classIndex)) {
                if (cls.type === "Handler") {
                    const hasManager = cls.relations.some(r => {
                        const target = appState.classIndex[r];
                        return target && target.type === "Manager";
                    });
                    if (!hasManager) {
                        issues.push(`‚ö†Ô∏è Handler ${cls.name} ne d√©l√®gue √† aucun Manager.`);
                    }
                }
            }

            // Managers sans container
            for (const cls of Object.values(appState.classIndex)) {
                if (cls.type === "Manager") {
                    const hasContainer = cls.relations.some(r => {
                        const target = appState.classIndex[r];
                        return target && target.type === "Container";
                    });
                    if (!hasContainer) {
                        issues.push(`‚ö†Ô∏è Manager ${cls.name} ne r√©f√©rence aucun Container.`);
                    }
                }
            }

            // Containers sans GameContainer
            for (const cls of Object.values(appState.classIndex)) {
                if (cls.type === "Container") {
                    const hasGame = cls.relations.some(r => r.includes("Game"));
                    if (!hasGame) {
                        issues.push(`‚ö†Ô∏è Container ${cls.name} ne contient aucun GameContainer.`);
                    }
                }
            }

            return issues;
        }
    </script>
</body>

</html>
</body>

</html>