# AI Coding Agent Instructions

## Project Overview
Unity multiplayer game framework with **session isolation** - multiple concurrent game sessions on one server, each with isolated player data, world space, and game state.

## Architecture

### Session Isolation System
- Core isolation boundary with unique world offset for spatial separation
- Isolated player registry with authorization checks
- Private game state and pawn management per session
- Always validate access before session operations
- Position all game objects relative to session world offset

### Game Plugin System
- Games implement IGameDefinition interface or inherit from GameDefinitionAsset ScriptableObject
- Games auto-register on server start
- Implement server-side setup, spawn position calculation, pawn initialization, and client-side visuals

### Networking (Unity Netcode for GameObjects)
- Use ServerRpc for client-to-server calls with RequireOwnership = false
- Use ClientRpc with ClientRpcParams for targeted server-to-client sends
- NetworkVariables use server authority with read permission Everyone
- RPC hub handles session management RPCs

### Bootstrap Pattern
- Server bootstrap parses command-line arguments and auto-starts server
- Client bootstrap connects via UnityTransport

## Development Workflows

### Building Dedicated Server
```powershell
# Unity Editor: File → Build Profiles → Server → Build
# Output: Build/Server/Server.exe (Windows) or Server.x86_64 (Linux)
```

### Running Dedicated Server
See SERVER_COMMANDS.txt for all commands. Common patterns:
```powershell
# Windows
Server.exe -batchmode -nographics -port 7777 -maxplayers 32

# Linux production (systemd service)
/opt/gameserver/Server.x86_64 -batchmode -nographics -port 7777
```

### Testing Session Isolation
Run automated tests via run_tests.bat:
```batch
run_tests.bat quick      # 2 sessions, 2 players
run_tests.bat normal     # 5 sessions, 4 players  
run_tests.bat stress     # 50 sessions, 8 players
run_tests.bat custom 10 8  # Custom: 10 sessions, 8 players
```
Tests validate cross-session isolation, authorization, world bounds. See Assets/Scripts/Tests/README.md.

## Conventions & Patterns

### Logging
- Use component name and session ID in log messages
- Format: `[ComponentName:SessionId]` or `[ComponentName]` for singletons
- Disable stack traces for Log/Warning on server startup

### Session Operations
When adding session functionality:
1. Add method with authorization check
2. Add ServerRpc calling the method
3. Extract client ID from ServerRpcParams
4. Return errors via targeted ClientRpc

### Adding New Games
1. Create ScriptableObject inheriting GameDefinitionAsset
2. Implement game-specific logic (setup, spawning, visuals)
3. Create pawn prefab with NetworkObject component
4. Asset auto-registers on server start
5. Reference in scene as needed

### Thread Safety
Use locks for concurrent access when adding new shared state. Follow existing patterns.

## Common Pitfalls
- ❌ Don't forget `worldOffset` when positioning game objects/pawns
- ❌ Don't skip authorization checks in SessionContainer operations
- ❌ Don't use cross-session player lookups - always operate within one SessionContainer
- ❌ Don't create GameObjects in `SetupClientVisuals()` when running as ScriptableObject asset
