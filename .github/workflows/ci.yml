name: CI (Unity + GHCR cache + Claude AutoFix)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch: {}

permissions:
  contents: write
  pull-requests: write
  packages: write

concurrency:
  group: ci-main
  cancel-in-progress: true

env:
  UNITY_PROJECT_PATH: .
  UNITY_PLATFORM: StandaloneLinux64
  UNITY_LOG_DIR: .ci_logs
  MAX_AI_ITERS: "5"

jobs:
  unity:
    runs-on: ubuntu-latest
    timeout-minutes: 90

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          lfs: true
          fetch-depth: 0

      - name: Preflight (repo sanity)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "${UNITY_LOG_DIR}"
          echo "Branch: ${GITHUB_REF_NAME}" | tee "${UNITY_LOG_DIR}/preflight.txt"
          echo "Commit: ${GITHUB_SHA}" | tee -a "${UNITY_LOG_DIR}/preflight.txt"
          echo "Unity project path: ${UNITY_PROJECT_PATH}" | tee -a "${UNITY_LOG_DIR}/preflight.txt"
          test -d "Assets" || (echo "âŒ Missing Assets/ (not a Unity project?)" && exit 1)
          test -d "ProjectSettings" || (echo "âŒ Missing ProjectSettings/" && exit 1)
          test -f "ProjectSettings/ProjectVersion.txt" || (echo "âŒ Missing ProjectSettings/ProjectVersion.txt" && exit 1)
          echo "âœ… Project looks like Unity"

      - name: Docker info
        shell: bash
        run: |
          set -euo pipefail
          docker version
          docker info | sed -n '1,140p'


      - name: Resolve latest compatible Unity Editor image (Claude chooses)
        id: resolve_image
        shell: bash
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          ANTHROPIC_MODEL: ${{ vars.ANTHROPIC_MODEL }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          UNITY_VERSION="$(awk '/m_EditorVersion:/ {print $2}' ProjectSettings/ProjectVersion.txt | tr -d '\r')"
          if [[ -z "${UNITY_VERSION:-}" ]]; then
            echo "âŒ Could not read Unity version from ProjectSettings/ProjectVersion.txt"
            exit 1
          fi
          echo "Unity version detected: ${UNITY_VERSION}"

          # Default model if vars.ANTHROPIC_MODEL is empty
          MODEL="${ANTHROPIC_MODEL:-claude-3-5-sonnet-20241022}"
          
          # Cost tracking (USD): Claude 3.5 Sonnet pricing
          # Input: ~$3/MTok, Output: ~$15/MTok
          MAX_COST_USD=100.0
          MAX_ATTEMPTS=10
          ATTEMPT=0
          CHOSEN_TAG=""
          COST_TRACKING_FILE="${UNITY_LOG_DIR}/claude_api_costs.txt"
          
          # Initialize or load cumulative cost from file
          mkdir -p "${UNITY_LOG_DIR}"
          if [[ -f "$COST_TRACKING_FILE" ]]; then
            CUMULATIVE_COST="$(cat "$COST_TRACKING_FILE" 2>/dev/null | head -n 1 | grep -oP '[\d.]+' | head -n 1 || echo "0.0")"
            echo "ðŸ“Š Loaded cumulative cost from file: $${CUMULATIVE_COST} USD"
          else
            CUMULATIVE_COST=0.0
            echo "ðŸ“Š Starting fresh cost tracking (file: ${COST_TRACKING_FILE})"
          fi
          
          # Session cost (costs for this run only)
          SESSION_COST=0.0
          
          # Helper function to save cost to file
          save_cost() {
            local new_total="$1"
            {
              echo "${new_total}"
              echo "# Last updated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
              echo "# Session cost: ${SESSION_COST}"
              echo "# Attempt: ${ATTEMPT}"
              echo "# Unity version: ${UNITY_VERSION}"
            } > "$COST_TRACKING_FILE"
          }
          
          if [[ -z "${ANTHROPIC_API_KEY:-}" ]]; then
            echo "âŒ ANTHROPIC_API_KEY missing -> cannot proceed"
            exit 1
          fi
          
          echo "=== Step 1: Asking Claude for prompt structure ==="
          
          # Ask Claude for the prompt structure it wants
          PROMPT_STRUCTURE_REQ="$(jq -n \
            --arg model "$MODEL" \
            '{model:$model, max_tokens:200, messages:[{role:"user", content:"I need to get the most recent Docker tag for Unity Editor from ghcr.io/game-ci/unity-editor. The Unity version is: {UNITY_VERSION}. Please provide me with a prompt structure (like a template) that you would like me to use to ask you for the specific tag. The structure should include placeholders for arguments like {UNITY_VERSION}. Output ONLY the prompt template, nothing else."}] }')"
          
          PROMPT_STRUCTURE_RESP="$(curl -fsSL "https://api.anthropic.com/v1/messages" \
            -H "content-type: application/json" \
            -H "x-api-key: ${ANTHROPIC_API_KEY}" \
            -H "anthropic-version: 2023-06-01" \
            -d "$PROMPT_STRUCTURE_REQ")"
          
          PROMPT_STRUCTURE="$(echo "$PROMPT_STRUCTURE_RESP" | jq -r '.content[0].text' | tr -d '\r')"
          INPUT_TOKENS_1="$(echo "$PROMPT_STRUCTURE_RESP" | jq -r '.usage.input_tokens // 0')"
          OUTPUT_TOKENS_1="$(echo "$PROMPT_STRUCTURE_RESP" | jq -r '.usage.output_tokens // 0')"
          # Calculate cost: Input $3/MTok, Output $15/MTok
          COST_1="$(python3 -c "print((${INPUT_TOKENS_1} * 3 + ${OUTPUT_TOKENS_1} * 15) / 1000000)" 2>/dev/null || \
            awk "BEGIN {printf \"%.6f\", (${INPUT_TOKENS_1} * 3 + ${OUTPUT_TOKENS_1} * 15) / 1000000}" 2>/dev/null || \
            echo "0.01")"
          SESSION_COST="$(python3 -c "print(${SESSION_COST} + ${COST_1})" 2>/dev/null || \
            awk "BEGIN {printf \"%.6f\", ${SESSION_COST} + ${COST_1}}" 2>/dev/null || \
            echo "${SESSION_COST}")"
          CUMULATIVE_COST="$(python3 -c "print(${CdUMULATIVE_COST} + ${COST_1})" 2>/dev/null || \
            awk "BEGIN {printf \"%.6f\", ${CUMULATIVE_COST} + ${COST_1}}" 2>/dev/null || \
            echo "${CUMULATIVE_COST}")"
          
          # Save to file
          save_cost "$CUMULATIVE_COST"
          
          echo "Prompt structure received (cost: ~$${COST_1}, session: ~$${SESSION_COST}, cumulative: ~$${CUMULATIVE_COST})"
          echo "Structure: ${PROMPT_STRUCTURE:0:200}..."
          
          if [[ -z "${PROMPT_STRUCTURE:-}" || "${PROMPT_STRUCTURE}" == "null" ]]; then
            echo "âŒ Failed to get prompt structure from Claude"
            exit 1
          fi
          
          # Replace placeholders in the structure with actual values
          FINAL_PROMPT="$(echo "$PROMPT_STRUCTURE" | sed "s/{UNITY_VERSION}/${UNITY_VERSION}/g")"
          
          echo ""
          echo "=== Step 2: Asking Claude for Docker tag (with retries) ==="
          
          while [[ $ATTEMPT -lt $MAX_ATTEMPTS ]]; do
            ATTEMPT=$((ATTEMPT + 1))
            
            # Check cost limit (using awk for comparison since it's more widely available)
            COST_EXCEEDED="$(awk "BEGIN {print (${CUMULATIVE_COST} > ${MAX_COST_USD})}" 2>/dev/null || echo "0")"
            if [[ "${COST_EXCEEDED}" == "1" ]]; then
              echo "âŒ Cost limit exceeded: $${CUMULATIVE_COST} > $${MAX_COST_USD}"
              echo "ðŸ“Š Final cost tracking saved to: ${COST_TRACKING_FILE}"
              exit 1
            fi
            
            echo "Attempt ${ATTEMPT}/${MAX_ATTEMPTS} (session: ~$${SESSION_COST}, cumulative: ~$${CUMULATIVE_COST})..."
            
            # Ask Claude for the tag using the structure
            TAG_REQ="$(jq -n \
              --arg model "$MODEL" \
              --arg text "$FINAL_PROMPT" \
              '{model:$model, max_tokens:100, messages:[{role:"user", content:$text}] }')"
            
            TAG_RESP="$(curl -fsSL "https://api.anthropic.com/v1/messages" \
              -H "content-type: application/json" \
              -H "x-api-key: ${ANTHROPIC_API_KEY}" \
              -H "anthropic-version: 2023-06-01" \
              -d "$TAG_REQ")"
            
            INPUT_TOKENS="$(echo "$TAG_RESP" | jq -r '.usage.input_tokens // 0')"
            OUTPUT_TOKENS="$(echo "$TAG_RESP" | jq -r '.usage.output_tokens // 0')"
            # Calculate cost: Input $3/MTok, Output $15/MTok
            COST="$(python3 -c "print((${INPUT_TOKENS} * 3 + ${OUTPUT_TOKENS} * 15) / 1000000)" 2>/dev/null || \
              awk "BEGIN {printf \"%.6f\", (${INPUT_TOKENS} * 3 + ${OUTPUT_TOKENS} * 15) / 1000000}" 2>/dev/null || \
              echo "0.01")"
            SESSION_COST="$(python3 -c "print(${SESSION_COST} + ${COST})" 2>/dev/null || \
              awk "BEGIN {printf \"%.6f\", ${SESSION_COST} + ${COST}}" 2>/dev/null || \
              echo "${SESSION_COST}")"
            CUMULATIVE_COST="$(python3 -c "print(${CUMULATIVE_COST} + ${COST})" 2>/dev/null || \
              awk "BEGIN {printf \"%.6f\", ${CUMULATIVE_COST} + ${COST}}" 2>/dev/null || \
              echo "${CUMULATIVE_COST}")"
            
            # Save to file after each request
            save_cost "$CUMULATIVE_COST"
            
            CHOSEN_TAG="$(echo "$TAG_RESP" | jq -r '.content[0].text' | head -n 1 | tr -d '\r' | xargs | sed 's/^[^a-zA-Z0-9]*//;s/[^a-zA-Z0-9-]*$//')"
            
            if [[ -z "${CHOSEN_TAG:-}" || "${CHOSEN_TAG}" == "null" ]]; then
              echo "âš ï¸ Claude returned empty tag, retrying... (cost so far: ~$${CUMULATIVE_COST})"
              sleep 1
              continue
            fi
            
            echo "  Claude suggested tag: ${CHOSEN_TAG} (cost: ~$${COST}, cumulative: ~$${CUMULATIVE_COST})"
            
            # Test if the tag works by trying to pull the image
            UPSTREAM_IMAGE="ghcr.io/game-ci/unity-editor:${CHOSEN_TAG}"
            echo "  Testing tag: ${UPSTREAM_IMAGE}..."
            
            if docker pull "${UPSTREAM_IMAGE}" >/dev/null 2>&1; then
              echo "  âœ… Tag ${CHOSEN_TAG} is valid and pullable!"
              break
            else
              echo "  âš ï¸ Tag ${CHOSEN_TAG} is not valid or not pullable, retrying..."
              CHOSEN_TAG=""
              sleep 2
            fi
          done
          
          if [[ -z "${CHOSEN_TAG:-}" ]]; then
            echo "âŒ Failed to get valid tag after ${MAX_ATTEMPTS} attempts"
            echo "ðŸ“Š Session cost: ~$${SESSION_COST} USD, Cumulative cost: ~$${CUMULATIVE_COST} USD"
            echo "ðŸ“Š Cost tracking saved to: ${COST_TRACKING_FILE}"
            exit 1
          fi
          
          echo "âœ… Successfully found valid tag: ${CHOSEN_TAG}"
          echo "ðŸ“Š Session cost: ~$${SESSION_COST} USD, Cumulative cost: ~$${CUMULATIVE_COST} USD"
          echo "ðŸ“Š Cost tracking saved to: ${COST_TRACKING_FILE}"

          UPSTREAM_IMAGE="ghcr.io/game-ci/unity-editor:${CHOSEN_TAG}"

          echo "Chosen upstream image: ${UPSTREAM_IMAGE}"
          echo "Note: Image already pulled during tag validation"

          # Export for next steps
          echo "UNITY_VERSION=${UNITY_VERSION}" >> "$GITHUB_OUTPUT"
          echo "UNITY_EDITOR_IMAGE=${UPSTREAM_IMAGE}" >> "$GITHUB_OUTPUT"
          echo "UNITY_EDITOR_IMAGE=${UPSTREAM_IMAGE}" >> "$GITHUB_ENV"

      - name: Unity compile + tests with Claude AutoFix (up to 5 iters)
        shell: bash
        env:
          # Anthropic
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          ANTHROPIC_MODEL: ${{ vars.ANTHROPIC_MODEL }}
          # Unity licensing (pass-through)
          UNITY_LICENSE: ${{ secrets.UNITY_LICENSE }}
          UNITY_EMAIL: ${{ secrets.UNITY_EMAIL }}
          UNITY_PASSWORD: ${{ secrets.UNITY_PASSWORD }}
          UNITY_SERIAL: ${{ secrets.UNITY_SERIAL }}
          # GitHub token for checkpoint commits
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          echo "Using cached Unity image: ${UNITY_EDITOR_IMAGE}"
          chmod +x scripts/unity_ai_loop.sh
          ./scripts/unity_ai_loop.sh
      - name: Upload logs + graph
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ci-logs-and-graph
          path: |
            .ci_logs
            .ci_graph

      - name: Report runner duration proxy (minutes)
        if: always()
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          echo "==== Actions duration (proxy) ===="
          RUN_JSON="$(gh api repos/${{ github.repository }}/actions/runs/${{ github.run_id }})"
          DURATION_MS="$(echo "$RUN_JSON" | jq -r '.run_duration_ms // .duration_ms // 0')"
          echo "run_duration_ms=$DURATION_MS"
          DURATION_MS="$DURATION_MS" python3 -c "import os; ms=int(os.environ.get('DURATION_MS','0') or 0); print(f'Approx runner time: {ms/60000:.2f} minutes' if ms else 'Could not read duration.')"
          echo "Cost depends on your GitHub plan (minutes quota / billing)."